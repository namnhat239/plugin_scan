{"version":3,"sources":["jquery-sortable.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","nested","$","pluginName","undefined","containerDefaults","drag","groupDefaults","exclude","containerPath","containerSelector","afterMove","$placeholder","container","$closestItemOrContainer","distance","draggedClass","handle","itemPath","itemSelector","bodyClass","onDrag","isValidTarget","$item","css","_super","event","position","addClass","onDragStart","removeClass","onMousedown","preventDefault","group","options","placeholderClass","removeAttr","target","nodeName","match","placeholder","pullPlaceholder","parentIsContainer","result","sortable","serialize","$parent","$children","extend","data","containerGroups","groupCounter","emptyBox","subContainers","drop","subContainerKey","left","top","bottom","x","Math","i","length","d","a","b","offsetMethod","parseInt","el","getRelativePosition","element","sortByDistanceDesc","tolerance","offset","pointer","pos","distances","dimensions","outerWidth","outerHeight","dim","dropProxy","dragProxy","sort","proxy","ContainerGroup","get","this","containers","rootGroup","closestItem","item","disabled","itemDimensions","right","which","find","originalEvent","on","eventNames","start","dragInit","searchValidTarget","push","setPointer","dragInitDone","dragging","setupDelayTimer","box","itemContainer","e","toggleListeners","onCancel","detach","delayMet","clearDimensions","clearOffsetParent","relativePointer","lastPointer","sameResultBox","t","offsetParent","lastRelativePointer","getContainer","getContainerDimensions","onDrop","movePlaceholder","lastAppendedItem","$getOffsetParent","containerDimensions","setDimensions","closest","method","getPointer","getItemOffsetParent","that","distanceMet","events","$document","pageX","pageY","currentPointer","clearTimeout","abs","_mouseDelayTimer","o","touches","scroll","_clearDimensions","delay","each","setTimeout","callback","traverse","object","isValidDrag","Container","validTarget","_destroy","inUpperHalf","xCenter","inLeftHalf","index","getItemDimensions","hasChildGroup","items","getContainerGroup","childGroup","childContainers","yCenter","height","path","_serialize","width","removeData","enable","parent","$getChildren","type","isContainer","childType","children","selector","not","map","disable","off","grep","val","destroy","refresh","args","$t","API"],"mappings":"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","file":"jquery-sortable.min.js","sourcesContent":["/* ===================================================\n *  jquery-sortable.js v0.9.13\n *  http://johnny.github.com/jquery-sortable/\n * ===================================================\n *  Copyright (c) 2012 Jonas von Andrian\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  * The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * ========================================================== */\n/* eslint-disable */\n!function ( $, window, pluginName, undefined){\n    var containerDefaults = {\n            // If true, items can be dragged from this container\n            drag: true,\n            // If true, items can be droped onto this container\n            drop: true,\n            // Exclude items from being draggable, if the\n            // selector matches the item\n            exclude: \"\",\n            // If true, search for nested containers within an item.If you nest containers,\n            // either the original selector with which you call the plugin must only match the top containers,\n            // or you need to specify a group (see the bootstrap nav example)\n            nested: true,\n            // If true, the items are assumed to be arranged vertically\n            vertical: true\n        }, // end container defaults\n        groupDefaults = {\n            // This is executed after the placeholder has been moved.\n            // $closestItemOrContainer contains the closest item, the placeholder\n            // has been put at or the closest empty Container, the placeholder has\n            // been appended to.\n            afterMove: function ($placeholder, container, $closestItemOrContainer) {\n            },\n            // The exact css path between the container and its items, e.g. \"> tbody\"\n            containerPath: \"\",\n            // The css selector of the containers\n            containerSelector: \"ol, ul\",\n            // Distance the mouse has to travel to start dragging\n            distance: 0,\n            // Time in milliseconds after mousedown until dragging should start.\n            // This option can be used to prevent unwanted drags when clicking on an element.\n            delay: 0,\n            // The css selector of the drag handle\n            handle: \"\",\n            // The exact css path between the item and its subcontainers.\n            // It should only match the immediate items of a container.\n            // No item of a subcontainer should be matched. E.g. for ol>div>li the itemPath is \"> div\"\n            itemPath: \"\",\n            // The css selector of the items\n            itemSelector: \"li\",\n            // The class given to \"body\" while an item is being dragged\n            bodyClass: \"dragging\",\n            // The class giving to an item while being dragged\n            draggedClass: \"dragged\",\n            // Check if the dragged item may be inside the container.\n            // Use with care, since the search for a valid container entails a depth first search\n            // and may be quite expensive.\n            isValidTarget: function ($item, container) {\n                return true\n            },\n            // Executed before onDrop if placeholder is detached.\n            // This happens if pullPlaceholder is set to false and the drop occurs outside a container.\n            onCancel: function ($item, container, _super, event) {\n            },\n            // Executed at the beginning of a mouse move event.\n            // The Placeholder has not been moved yet.\n            onDrag: function ($item, position, _super, event) {\n                $item.css(position)\n            },\n            // Called after the drag has been started,\n            // that is the mouse button is being held down and\n            // the mouse is moving.\n            // The container is the closest initialized container.\n            // Therefore it might not be the container, that actually contains the item.\n            onDragStart: function ($item, container, _super, event) {\n                $item.css({\n                    height: $item.outerHeight(),\n                    width: $item.outerWidth()\n                })\n                $item.addClass(container.group.options.draggedClass)\n                $(\"body\").addClass(container.group.options.bodyClass)\n            },\n            // Called when the mouse button is being released\n            onDrop: function ($item, container, _super, event) {\n                $item.removeClass(container.group.options.draggedClass).removeAttr(\"style\")\n                $(\"body\").removeClass(container.group.options.bodyClass)\n            },\n            // Called on mousedown. If falsy value is returned, the dragging will not start.\n            // Ignore if element clicked is input, select or textarea\n            onMousedown: function ($item, _super, event) {\n                if (!event.target.nodeName.match(/^(input|select|textarea)$/i)) {\n                    event.preventDefault()\n                    return true\n                }\n            },\n            // The class of the placeholder (must match placeholder option markup)\n            placeholderClass: \"placeholder\",\n            // Template for the placeholder. Can be any valid jQuery input\n            // e.g. a string, a DOM element.\n            // The placeholder must have the class \"placeholder\"\n            placeholder: '<li class=\"placeholder\"></li>',\n            // If true, the position of the placeholder is calculated on every mousemove.\n            // If false, it is only calculated when the mouse is above a container.\n            pullPlaceholder: true,\n            // Specifies serialization of the container group.\n            // The pair $parent/$children is either container/items or item/subcontainers.\n            serialize: function ($parent, $children, parentIsContainer) {\n                var result = $.extend({}, $parent.data())\n\n                if(parentIsContainer)\n                    return [$children]\n                else if ($children[0]){\n                    result.children = $children\n                }\n\n                delete result.subContainers\n                delete result.sortable\n\n                return result\n            },\n            // Set tolerance while dragging. Positive values decrease sensitivity,\n            // negative values increase it.\n            tolerance: 0\n        }, // end group defaults\n        containerGroups = {},\n        groupCounter = 0,\n        emptyBox = {\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right:0\n        },\n        eventNames = {\n            start: \"touchstart.sortable mousedown.sortable\",\n            drop: \"touchend.sortable touchcancel.sortable mouseup.sortable\",\n            drag: \"touchmove.sortable mousemove.sortable\",\n            scroll: \"scroll.sortable\"\n        },\n        subContainerKey = \"subContainers\"\n\n    /*\n     * a is Array [left, right, top, bottom]\n     * b is array [left, top]\n     */\n    function d(a,b) {\n        var x = Math.max(0, a[0] - b[0], b[0] - a[1]),\n            y = Math.max(0, a[2] - b[1], b[1] - a[3])\n        return x+y;\n    }\n\n    function setDimensions(array, dimensions, tolerance, useOffset) {\n        var i = array.length,\n            offsetMethod = useOffset ? \"offset\" : \"position\"\n        tolerance = tolerance || 0\n\n        while(i--){\n            var el = array[i].el ? array[i].el : $(array[i]),\n            // use fitting method\n                pos = el[offsetMethod]()\n            pos.left += parseInt(el.css('margin-left'), 10)\n            pos.top += parseInt(el.css('margin-top'),10)\n            dimensions[i] = [\n                pos.left - tolerance,\n                pos.left + el.outerWidth() + tolerance,\n                pos.top - tolerance,\n                pos.top + el.outerHeight() + tolerance\n            ]\n        }\n    }\n\n    function getRelativePosition(pointer, element) {\n        var offset = element.offset()\n        return {\n            left: pointer.left - offset.left,\n            top: pointer.top - offset.top\n        }\n    }\n\n    function sortByDistanceDesc(dimensions, pointer, lastPointer) {\n        pointer = [pointer.left, pointer.top]\n        lastPointer = lastPointer && [lastPointer.left, lastPointer.top]\n\n        var dim,\n            i = dimensions.length,\n            distances = []\n\n        while(i--){\n            dim = dimensions[i]\n            distances[i] = [i,d(dim,pointer), lastPointer && d(dim, lastPointer)]\n        }\n        distances = distances.sort(function  (a,b) {\n            return b[1] - a[1] || b[2] - a[2] || b[0] - a[0]\n        })\n\n        // last entry is the closest\n        return distances\n    }\n\n    function ContainerGroup(options) {\n        this.options = $.extend({}, groupDefaults, options)\n        this.containers = []\n\n        if(!this.options.rootGroup){\n            this.scrollProxy = $.proxy(this.scroll, this)\n            this.dragProxy = $.proxy(this.drag, this)\n            this.dropProxy = $.proxy(this.drop, this)\n            this.placeholder = $(this.options.placeholder)\n\n            if(!options.isValidTarget)\n                this.options.isValidTarget = undefined\n        }\n    }\n\n    ContainerGroup.get = function  (options) {\n        if(!containerGroups[options.group]) {\n            if(options.group === undefined)\n                options.group = groupCounter ++\n\n            containerGroups[options.group] = new ContainerGroup(options)\n        }\n\n        return containerGroups[options.group]\n    }\n\n    ContainerGroup.prototype = {\n        dragInit: function  (e, itemContainer) {\n            this.$document = $(itemContainer.el[0].ownerDocument)\n\n            // get item to drag\n            var closestItem = $(e.target).closest(this.options.itemSelector);\n            // using the length of this item, prevents the plugin from being started if there is no handle being clicked on.\n            // this may also be helpful in instantiating multidrag.\n            if (closestItem.length) {\n                this.item = closestItem;\n                this.itemContainer = itemContainer;\n                if (this.item.is(this.options.exclude) || !this.options.onMousedown(this.item, groupDefaults.onMousedown, e)) {\n                    return;\n                }\n                this.setPointer(e);\n                this.toggleListeners('on');\n                this.setupDelayTimer();\n                this.dragInitDone = true;\n            }\n        },\n        drag: function  (e) {\n            if(!this.dragging){\n                if(!this.distanceMet(e) || !this.delayMet)\n                    return\n\n                this.options.onDragStart(this.item, this.itemContainer, groupDefaults.onDragStart, e)\n                this.item.before(this.placeholder)\n                this.dragging = true\n            }\n\n            this.setPointer(e)\n            // place item under the cursor\n            this.options.onDrag(this.item,\n                getRelativePosition(this.pointer, this.item.offsetParent()),\n                groupDefaults.onDrag,\n                e)\n\n            var p = this.getPointer(e),\n                box = this.sameResultBox,\n                t = this.options.tolerance\n\n            if(!box || box.top - t > p.top || box.bottom + t < p.top || box.left - t > p.left || box.right + t < p.left)\n                if(!this.searchValidTarget()){\n                    this.placeholder.detach()\n                    this.lastAppendedItem = undefined\n                }\n        },\n        drop: function  (e) {\n            this.toggleListeners('off')\n\n            this.dragInitDone = false\n\n            if(this.dragging){\n                // processing Drop, check if placeholder is detached\n                if(this.placeholder.closest(\"html\")[0]){\n                    this.placeholder.before(this.item).detach()\n                } else {\n                    this.options.onCancel(this.item, this.itemContainer, groupDefaults.onCancel, e)\n                }\n                this.options.onDrop(this.item, this.getContainer(this.item), groupDefaults.onDrop, e)\n\n                // cleanup\n                this.clearDimensions()\n                this.clearOffsetParent()\n                this.lastAppendedItem = this.sameResultBox = undefined\n                this.dragging = false\n            }\n        },\n        searchValidTarget: function  (pointer, lastPointer) {\n            if(!pointer){\n                pointer = this.relativePointer || this.pointer\n                lastPointer = this.lastRelativePointer || this.lastPointer\n            }\n\n            var distances = sortByDistanceDesc(this.getContainerDimensions(),\n                    pointer,\n                    lastPointer),\n                i = distances.length\n\n            while(i--){\n                var index = distances[i][0],\n                    distance = distances[i][1]\n\n                if(!distance || this.options.pullPlaceholder){\n                    var container = this.containers[index]\n                    if(!container.disabled){\n                        if(!this.$getOffsetParent()){\n                            var offsetParent = container.getItemOffsetParent()\n                            pointer = getRelativePosition(pointer, offsetParent)\n                            lastPointer = getRelativePosition(lastPointer, offsetParent)\n                        }\n                        if(container.searchValidTarget(pointer, lastPointer))\n                            return true\n                    }\n                }\n            }\n            if(this.sameResultBox)\n                this.sameResultBox = undefined\n        },\n        movePlaceholder: function  (container, item, method, sameResultBox) {\n            var lastAppendedItem = this.lastAppendedItem\n            if(!sameResultBox && lastAppendedItem && lastAppendedItem[0] === item[0])\n                return;\n\n            item[method](this.placeholder)\n            this.lastAppendedItem = item\n            this.sameResultBox = sameResultBox\n            this.options.afterMove(this.placeholder, container, item)\n        },\n        getContainerDimensions: function  () {\n            if(!this.containerDimensions)\n                setDimensions(this.containers, this.containerDimensions = [], this.options.tolerance, !this.$getOffsetParent())\n            return this.containerDimensions\n        },\n        getContainer: function  (element) {\n            return element.closest(this.options.containerSelector).data(pluginName)\n        },\n        $getOffsetParent: function  () {\n            if(this.offsetParent === undefined){\n                var i = this.containers.length - 1,\n                    offsetParent = this.containers[i].getItemOffsetParent()\n\n                if(!this.options.rootGroup){\n                    while(i--){\n                        if(offsetParent[0] != this.containers[i].getItemOffsetParent()[0]){\n                            // If every container has the same offset parent,\n                            // use position() which is relative to this parent,\n                            // otherwise use offset()\n                            // compare #setDimensions\n                            offsetParent = false\n                            break;\n                        }\n                    }\n                }\n\n                this.offsetParent = offsetParent\n            }\n            return this.offsetParent\n        },\n        setPointer: function (e) {\n            var pointer = this.getPointer(e)\n\n            if(this.$getOffsetParent()){\n                var relativePointer = getRelativePosition(pointer, this.$getOffsetParent())\n                this.lastRelativePointer = this.relativePointer\n                this.relativePointer = relativePointer\n            }\n\n            this.lastPointer = this.pointer\n            this.pointer = pointer\n        },\n        distanceMet: function (e) {\n            var currentPointer = this.getPointer(e)\n            return (Math.max(\n                Math.abs(this.pointer.left - currentPointer.left),\n                Math.abs(this.pointer.top - currentPointer.top)\n            ) >= this.options.distance)\n        },\n        getPointer: function(e) {\n            var o = e.originalEvent || e.originalEvent.touches && e.originalEvent.touches[0]\n            return {\n                left: e.pageX || o.pageX,\n                top: e.pageY || o.pageY\n            }\n        },\n        setupDelayTimer: function () {\n            var that = this\n            this.delayMet = !this.options.delay\n\n            // init delay timer if needed\n            if (!this.delayMet) {\n                clearTimeout(this._mouseDelayTimer);\n                this._mouseDelayTimer = setTimeout(function() {\n                    that.delayMet = true\n                }, this.options.delay)\n            }\n        },\n        scroll: function  (e) {\n            this.clearDimensions()\n            this.clearOffsetParent() // TODO is this needed?\n        },\n        toggleListeners: function (method) {\n            var that = this,\n                events = ['drag','drop','scroll']\n\n            $.each(events,function  (i,event) {\n                that.$document[method](eventNames[event], that[event + 'Proxy'])\n            })\n        },\n        clearOffsetParent: function () {\n            this.offsetParent = undefined\n        },\n        // Recursively clear container and item dimensions\n        clearDimensions: function  () {\n            this.traverse(function(object){\n                object._clearDimensions()\n            })\n        },\n        traverse: function(callback) {\n            callback(this)\n            var i = this.containers.length\n            while(i--){\n                this.containers[i].traverse(callback)\n            }\n        },\n        _clearDimensions: function(){\n            this.containerDimensions = undefined\n        },\n        _destroy: function () {\n            containerGroups[this.options.group] = undefined\n        }\n    }\n\n    function Container(element, options) {\n        this.el = element\n        this.options = $.extend( {}, containerDefaults, options)\n\n        this.group = ContainerGroup.get(this.options)\n        this.rootGroup = this.options.rootGroup || this.group\n        this.handle = this.rootGroup.options.handle || this.rootGroup.options.itemSelector\n\n        var itemPath = this.rootGroup.options.itemPath\n        this.target = itemPath ? this.el.find(itemPath) : this.el\n\n        this.target.on(eventNames.start, this.handle, $.proxy(this.dragInit, this))\n\n        if(this.options.drop)\n            this.group.containers.push(this)\n    }\n\n    Container.prototype = {\n        dragInit: function  (e) {\n            var rootGroup = this.rootGroup\n\n            if( !this.disabled &&\n                !rootGroup.dragInitDone &&\n                this.options.drag &&\n                this.isValidDrag(e)) {\n                rootGroup.dragInit(e, this)\n            }\n        },\n        isValidDrag: function(e) {\n            return e.which == 1 ||\n            e.type == \"touchstart\" && e.originalEvent.touches.length == 1\n        },\n        searchValidTarget: function  (pointer, lastPointer) {\n            var distances = sortByDistanceDesc(this.getItemDimensions(),\n                    pointer,\n                    lastPointer),\n                i = distances.length,\n                rootGroup = this.rootGroup,\n                validTarget = !rootGroup.options.isValidTarget ||\n                    rootGroup.options.isValidTarget(rootGroup.item, this)\n\n            if(!i && validTarget){\n                rootGroup.movePlaceholder(this, this.target, \"append\")\n                return true\n            } else\n                while(i--){\n                    var index = distances[i][0],\n                        distance = distances[i][1]\n                    if(!distance && this.hasChildGroup(index)){\n                        var found = this.getContainerGroup(index).searchValidTarget(pointer, lastPointer)\n                        if(found)\n                            return true\n                    }\n                    else if(validTarget){\n                        this.movePlaceholder(index, pointer)\n                        return true\n                    }\n                }\n        },\n        movePlaceholder: function  (index, pointer) {\n            var item = $(this.items[index]),\n                dim = this.itemDimensions[index],\n                method = \"after\",\n                width = item.outerWidth(),\n                height = item.outerHeight(),\n                offset = item.offset(),\n                sameResultBox = {\n                    left: offset.left,\n                    right: offset.left + width,\n                    top: offset.top,\n                    bottom: offset.top + height\n                }\n            if(this.options.vertical){\n                var yCenter = (dim[2] + dim[3]) / 2,\n                    inUpperHalf = pointer.top <= yCenter\n                if(inUpperHalf){\n                    method = \"before\"\n                    sameResultBox.bottom -= height / 2\n                } else\n                    sameResultBox.top += height / 2\n            } else {\n                var xCenter = (dim[0] + dim[1]) / 2,\n                    inLeftHalf = pointer.left <= xCenter\n                if(inLeftHalf){\n                    method = \"before\"\n                    sameResultBox.right -= width / 2\n                } else\n                    sameResultBox.left += width / 2\n            }\n            if(this.hasChildGroup(index))\n                sameResultBox = emptyBox\n            this.rootGroup.movePlaceholder(this, item, method, sameResultBox)\n        },\n        getItemDimensions: function  () {\n            if(!this.itemDimensions){\n                this.items = this.$getChildren(this.el, \"item\").filter(\n                    \":not(.\" + this.group.options.placeholderClass + \", .\" + this.group.options.draggedClass + \")\"\n                ).get()\n                setDimensions(this.items, this.itemDimensions = [], this.options.tolerance)\n            }\n            return this.itemDimensions\n        },\n        getItemOffsetParent: function  () {\n            var offsetParent,\n                el = this.el\n            // Since el might be empty we have to check el itself and\n            // can not do something like el.children().first().offsetParent()\n            if(el.css(\"position\") === \"relative\" || el.css(\"position\") === \"absolute\"  || el.css(\"position\") === \"fixed\")\n                offsetParent = el\n            else\n                offsetParent = el.offsetParent()\n            return offsetParent\n        },\n        hasChildGroup: function (index) {\n            return this.options.nested && this.getContainerGroup(index)\n        },\n        getContainerGroup: function  (index) {\n            var childGroup = $.data(this.items[index], subContainerKey)\n            if( childGroup === undefined){\n                var childContainers = this.$getChildren(this.items[index], \"container\")\n                childGroup = false\n\n                if(childContainers[0]){\n                    var options = $.extend({}, this.options, {\n                        rootGroup: this.rootGroup,\n                        group: groupCounter ++\n                    })\n                    childGroup = childContainers[pluginName](options).data(pluginName).group\n                }\n                $.data(this.items[index], subContainerKey, childGroup)\n            }\n            return childGroup\n        },\n        $getChildren: function (parent, type) {\n            var options = this.rootGroup.options,\n                path = options[type + \"Path\"],\n                selector = options[type + \"Selector\"]\n\n            parent = $(parent)\n            if(path)\n                parent = parent.find(path)\n\n            return parent.children(selector)\n        },\n        _serialize: function (parent, isContainer) {\n            var that = this,\n                childType = isContainer ? \"item\" : \"container\",\n\n                children = this.$getChildren(parent, childType).not(this.options.exclude).map(function () {\n                    return that._serialize($(this), !isContainer)\n                }).get()\n\n            return this.rootGroup.options.serialize(parent, children, isContainer)\n        },\n        traverse: function(callback) {\n            $.each(this.items || [], function(item){\n                var group = $.data(this, subContainerKey)\n                if(group)\n                    group.traverse(callback)\n            });\n\n            callback(this)\n        },\n        _clearDimensions: function  () {\n            this.itemDimensions = undefined\n        },\n        _destroy: function() {\n            var that = this;\n\n            this.target.off(eventNames.start, this.handle);\n            this.el.removeData(pluginName)\n\n            if(this.options.drop)\n                this.group.containers = $.grep(this.group.containers, function(val){\n                    return val != that\n                })\n\n            $.each(this.items || [], function(){\n                $.removeData(this, subContainerKey)\n            })\n        }\n    }\n\n    var API = {\n        enable: function() {\n            this.traverse(function(object){\n                object.disabled = false\n            })\n        },\n        disable: function (){\n            this.traverse(function(object){\n                object.disabled = true\n            })\n        },\n        serialize: function () {\n            return this._serialize(this.el, true)\n        },\n        refresh: function() {\n            this.traverse(function(object){\n                object._clearDimensions()\n            })\n        },\n        destroy: function () {\n            this.traverse(function(object){\n                object._destroy();\n            })\n        }\n    }\n\n    $.extend(Container.prototype, API)\n\n    /**\n     * jQuery API\n     *\n     * Parameters are\n     *   either options on init\n     *   or a method name followed by arguments to pass to the method\n     */\n    $.fn[pluginName] = function(methodOrOptions) {\n        var args = Array.prototype.slice.call(arguments, 1)\n\n        return this.map(function(){\n            var $t = $(this),\n                object = $t.data(pluginName)\n\n            if(object && API[methodOrOptions])\n                return API[methodOrOptions].apply(object, args) || this\n            else if(!object && (methodOrOptions === undefined ||\n                typeof methodOrOptions === \"object\"))\n                $t.data(pluginName, new Container($t, methodOrOptions))\n\n            return this\n        });\n    };\n\n}(jQuery, window, 'wf_sortable');\n"]}